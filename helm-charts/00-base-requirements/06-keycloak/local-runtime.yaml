# This scenario creates a single-instance standalone Keycloak
# machine, with the most basic configuration and limited
# resource to be fit in a local K3s/Minukube environment
###############################################################

# Number of Keycloak replicas to deploy
replicaCount: 1

# Disable PostgreSQL dependency
postgresql:
  enabled: false

#image:
#  registry: registry.smc.it:49083
#  repository: openk9/my-keycloak
#  tag: 0.0.1

  pullPolicy: Always

  # Optionally specify an array of imagePullSecrets.
  # Secrets must be manually created in the namespace.
  # ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
  # e.g:
  # pullSecrets:
  #   - myRegistryKeySecretName
  #
#  pullSecrets:
#    - registry.smc.it

externalDatabase:
  host: postgresql
  port: 5432
  user: keycloak
  database: keycloak
  existingSecret: postgresql-keycloak-secret
  existingSecretPasswordKey: "password"  

service:
  type: ClusterIP
  ports:
    http: 80

production: true

proxy: edge

auth:
  ## @param auth.adminUser Keycloak administrator user
  ##
  adminUser: user
  ## @param auth.adminPassword Keycloak administrator password for the new user
  ##
  #adminPassword: ""
  ## @param auth.existingSecret Existing secret containing Keycloak admin password
  ##
  existingSecret: "keycloak-secret"
  ## @param auth.passwordSecretKey Key where the Keycloak admin password is being stored inside the existing secret.
  ##
  passwordSecretKey: "admin-password"


ingress:
  ## @param ingress.enabled Enable ingress record generation for Keycloak
  ##
  enabled: false
  ingressClassName: ""
  pathType: Prefix
  apiVersion: "networking.k8s.io/v1"
  hostname: keycloak.openk9.local  #-TOMD
  path: /
  servicePort: 80
  ## @param ingress.annotations [object] Additional annotations for the Ingress resource. To enable certificate autogeneration, place here your cert-manager annotations.
  ## Use this parameter to set the required annotations for cert-manager, see
  ## ref: https://cert-manager.io/docs/usage/ingress/#supported-annotations
  ## e.g:
  ## annotations:
  ##   kubernetes.io/ingress.class: nginx
  ##   cert-manager.io/cluster-issuer: cluster-issuer-name
  ##
  #annotations:
  ## @param ingress.tls Enable TLS configuration for the host defined at `ingress.hostname` parameter
  ## TLS certificates will be retrieved from a TLS secret with name: `{{- printf "%s-tls" (tpl .Values.ingress.hostname .) }}`
  ## You can:
  ##   - Use the `ingress.secrets` parameter to create this TLS secret
  ##   - Rely on cert-manager to create it by setting the corresponding annotations
  ##   - Rely on Helm to create self-signed certificates by setting `ingress.selfSigned=true`
  ##
  tls: true
  ## @param ingress.selfSigned Create a TLS secret for this ingress record using self-signed certificates generated by Helm
  ##
  selfSigned: false
 # extraTls:
 #   hosts: keycloak-mi.openk9.io
 #  secretName: openk9-tls-star-secret


## Metrics configuration
##
metrics:
  ## @param metrics.enabled Enable exposing Keycloak statistics
  ## ref: https://github.com/bitnami/containers/tree/main/bitnami/keycloak#enabling-statistics
  ##
  enabled: false
  ##
  serviceMonitor:
    ## @param metrics.serviceMonitor.enabled Create ServiceMonitor Resource for scraping metrics using PrometheusOperator
    ##
    enabled: false
    ## @param metrics.serviceMonitor.port Metrics service HTTP port
    ##
    port: http
    ## @param metrics.serviceMonitor.endpoints [array] The endpoint configuration of the ServiceMonitor. Path is mandatory. Interval, timeout and labellings can be overwritten.
    ##
    endpoints:
    #  - path: '{{ include "keycloak.httpPath" . }}metrics'
    #  - path: '{{ include "keycloak.httpPath" . }}realms/master/metrics'
      - path: '/metrics'
      - path: '/realms/master/metrics'
    ## @param metrics.serviceMonitor.path Metrics service HTTP path. Deprecated: Use @param metrics.serviceMonitor.endpoints instead
    ##
    path: ""
    ## @param metrics.serviceMonitor.namespace Namespace which Prometheus is running in
    ##
    namespace: ""
    ## @param metrics.serviceMonitor.interval Interval at which metrics should be scraped
    ##
    interval: 30s
    ## @param metrics.serviceMonitor.scrapeTimeout Specify the timeout after which the scrape is ended
    ## e.g:
    ##   scrapeTimeout: 30s
    ##
    scrapeTimeout: ""
    ## @param metrics.serviceMonitor.labels Additional labels that can be used so ServiceMonitor will be discovered by Prometheus
    ##
    labels:
      release: prometheus-stack
    ## @param metrics.serviceMonitor.selector Prometheus instance selector labels
    ## ref: https://github.com/bitnami/charts/tree/main/bitnami/prometheus-operator#prometheus-configuration
    ##
    selector: {}
    ## @param metrics.serviceMonitor.relabelings RelabelConfigs to apply to samples before scraping
    ##
    relabelings: []
    ## @param metrics.serviceMonitor.metricRelabelings MetricRelabelConfigs to apply to samples before ingestion
    ##
    metricRelabelings: []
    ## @param metrics.serviceMonitor.honorLabels honorLabels chooses the metric's labels on collisions with target labels
    ##
    honorLabels: false
    ## @param metrics.serviceMonitor.jobLabel The name of the label on the target service to use as the job name in prometheus.
    ##
    jobLabel: "keycloak"
  ## Prometheus Operator alert rules configuration
  ##
  prometheusRule:
    ## @param metrics.prometheusRule.enabled Create PrometheusRule Resource for scraping metrics using PrometheusOperator
    ##
    enabled: false
    ## @param metrics.prometheusRule.namespace Namespace which Prometheus is running in  