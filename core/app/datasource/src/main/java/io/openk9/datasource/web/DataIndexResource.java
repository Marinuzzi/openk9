package io.openk9.datasource.web;

import io.openk9.datasource.index.mappings.MappingsKey;
import io.openk9.datasource.index.mappings.MappingsUtil;
import io.openk9.datasource.model.DataIndex;
import io.openk9.datasource.model.Datasource;
import io.openk9.datasource.model.Datasource_;
import io.openk9.datasource.model.DocType;
import io.openk9.datasource.processor.indexwriter.IndexerEvents;
import io.openk9.datasource.service.DocTypeService;
import io.smallrye.mutiny.Uni;
import io.smallrye.mutiny.unchecked.Unchecked;
import io.vertx.core.json.Json;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.eclipse.microprofile.faulttolerance.CircuitBreaker;
import org.elasticsearch.client.IndicesClient;
import org.elasticsearch.client.RequestOptions;
import org.elasticsearch.client.RestHighLevelClient;
import org.elasticsearch.client.indices.PutComposableIndexTemplateRequest;
import org.elasticsearch.cluster.metadata.ComposableIndexTemplate;
import org.elasticsearch.cluster.metadata.Template;
import org.elasticsearch.common.compress.CompressedXContent;
import org.elasticsearch.common.settings.Settings;
import org.hibernate.reactive.mutiny.Mutiny;

import javax.annotation.security.RolesAllowed;
import javax.inject.Inject;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Root;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import java.time.OffsetDateTime;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

@CircuitBreaker
@Path("/v1/data-index")
@RolesAllowed("k9-admin")
public class DataIndexResource {

	@Path("/auto-generate-doc-types")
	@POST
	public Uni<Void> autoGenerateDocTypes(
		AutoGenerateDocTypesRequest request) {

		return sessionFactory.withTransaction(session -> {

			CriteriaBuilder cb = sessionFactory.getCriteriaBuilder();

			CriteriaQuery<DataIndex> query = cb.createQuery(DataIndex.class);

			Root<Datasource> from = query.from(Datasource.class);

			query.select(from.get(Datasource_.dataIndex));

			query.where(from.get(Datasource_.id).in(request.getDatasourceId()));

			return session
				.createQuery(query)
				.getSingleResult()
				.onItem()
				.transformToUni(dataIndex -> indexerEvents.generateDocTypeFields(dataIndex));

		});

	}

	@Path("/get-mappings-from-doc-types")
	@POST
	public Uni<Map<MappingsKey, Object>> getMappings(
		GetMappingsOrSettingsFromDocTypesRequest request) {

		return getMappingsFromDocTypes(request.getDocTypeIds());

	}

	@Path("/get-settings-from-doc-types")
	@POST
	public Uni<Map<String, Object>> getSettings(
		GetMappingsOrSettingsFromDocTypesRequest request) {

		return getSettingsFromDocTypes(request.getDocTypeIds());

	}

	@Path("/create-data-index-from-doc-types/{datasourceId}")
	@POST
	public Uni<DataIndex> createDataIndexFromDocTypes(
		@PathParam("datasourceId") long datasourceId,
		CreateDataIndexFromDocTypesRequest request) {

		String indexName;

		if (request.getIndexName() == null) {
			indexName = "data-" + OffsetDateTime.now();
		}
		else {
			indexName = request.getIndexName();
		}

		return sessionFactory.withTransaction(s -> {

			List<Long> docTypeIds = request.getDocTypeIds();

			Uni<List<DocType>> docTypeListUni =
				_findDocTypes(docTypeIds, s, true);

			return docTypeListUni
				.onItem()
				.transformToUni(Unchecked.function(docTypeList -> {

					if (docTypeList.size() != docTypeIds.size()) {
						throw new RuntimeException(
							"docTypeIds found: " + docTypeList.size() +
							" docTypeIds requested: " + docTypeIds.size());
					}

					DataIndex dataIndex = new DataIndex();

					dataIndex.setDescription("auto-generated");

					dataIndex.setName(indexName);

					dataIndex.setDocTypes(new LinkedHashSet<>(docTypeList));

					dataIndex.setDatasource(s.getReference(Datasource.class, datasourceId));

					return s.persist(dataIndex)
						.map(__ -> dataIndex)
						.call(s::flush)
						.call((di) -> Uni.createFrom().emitter((sink) -> {

							try {
								IndicesClient indices = client.indices();

								Map<MappingsKey, Object> mappings =
									MappingsUtil.docTypesToMappings(di.getDocTypes());

								Settings settings;

								Map<String, Object> settingsMap =
									MappingsUtil.docTypesToSettings(di.getDocTypes());

								if (settingsMap.isEmpty()) {
									settings = Settings.EMPTY;
								}
								else {
									settings = Settings.builder()
										.loadFromMap(settingsMap)
										.build();
								}

								PutComposableIndexTemplateRequest
									putComposableIndexTemplateRequest =
									new PutComposableIndexTemplateRequest();

								ComposableIndexTemplate composableIndexTemplate =
									new ComposableIndexTemplate(
										List.of(indexName),
										new Template(settings, new CompressedXContent(
											Json.encode(mappings)), null),
										null, null, null, null);

								putComposableIndexTemplateRequest
									.name(indexName + "-template")
									.indexTemplate(composableIndexTemplate);

								indices.putIndexTemplate(putComposableIndexTemplateRequest, RequestOptions.DEFAULT);

								sink.complete(null);
							}
							catch (Exception e) {
								sink.fail(e);
							}

						}));

				}));

		});

	}

	private Uni<Map<MappingsKey, Object>> getMappingsFromDocTypes(
		List<Long> docTypeIds) {

		return sessionFactory.withTransaction(session -> {

			Uni<List<DocType>> docTypeListUni =
				_findDocTypes(docTypeIds, session, false);

			return docTypeListUni.map(MappingsUtil::docTypesToMappings);

		});
	}

	private Uni<Map<String, Object>> getSettingsFromDocTypes(
		List<Long> docTypeIds) {

		return sessionFactory.withTransaction(session -> {

			Uni<List<DocType>> docTypeListUni =
				_findDocTypes(docTypeIds, session, true);

			return docTypeListUni.map(MappingsUtil::docTypesToSettings);

		});
	}

	private Uni<List<DocType>> _findDocTypes(
		List<Long> docTypeIds, Mutiny.Session session, boolean includeAnalyzerSubtypes) {

		return docTypeService
			.getDocTypesAndDocTypeFields(docTypeIds)
			.map(LinkedList::new);
	}

	@Data
	@AllArgsConstructor
	@NoArgsConstructor
	public static class AutoGenerateDocTypesRequest {
		private long datasourceId;
	}

	@Data
	@AllArgsConstructor
	@NoArgsConstructor
	public static class GetMappingsOrSettingsFromDocTypesRequest {
		private List<Long> docTypeIds;
	}

	@Data
	@AllArgsConstructor
	@NoArgsConstructor
	public static class CreateDataIndexFromDocTypesRequest {
		private List<Long> docTypeIds;
		private String indexName;
	}

	@Inject
	Mutiny.SessionFactory sessionFactory;

	@Inject
	IndexerEvents indexerEvents;

	@Inject
	RestHighLevelClient client;

	@Inject
	DocTypeService docTypeService;

}
