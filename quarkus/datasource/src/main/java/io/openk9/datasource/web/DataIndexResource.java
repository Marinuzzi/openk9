package io.openk9.datasource.web;

import io.openk9.datasource.model.DataIndex;
import io.openk9.datasource.model.Datasource;
import io.openk9.datasource.model.Datasource_;
import io.openk9.datasource.model.DocType;
import io.openk9.datasource.model.DocTypeField;
import io.openk9.datasource.model.DocType_;
import io.openk9.datasource.model.FieldType;
import io.openk9.datasource.model.util.Analyzer;
import io.openk9.datasource.processor.indexwriter.IndexerEvents;
import io.smallrye.mutiny.Uni;
import io.vertx.core.json.Json;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.eclipse.microprofile.faulttolerance.CircuitBreaker;
import org.elasticsearch.client.IndicesClient;
import org.elasticsearch.client.RequestOptions;
import org.elasticsearch.client.RestHighLevelClient;
import org.elasticsearch.client.indices.PutComposableIndexTemplateRequest;
import org.elasticsearch.cluster.metadata.ComposableIndexTemplate;
import org.elasticsearch.cluster.metadata.Template;
import org.elasticsearch.common.compress.CompressedXContent;
import org.hibernate.reactive.mutiny.Mutiny;

import javax.inject.Inject;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Root;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import java.time.OffsetDateTime;
import java.util.Collection;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@CircuitBreaker
@Path("/v1/data-index")
public class DataIndexResource {

	@Path("/auto-generate-doc-types")
	@POST
	public Uni<Void> autoGenerateDocTypes(
		AutoGenerateDocTypesRequest request) {

		return sf.withTransaction(session -> {

			CriteriaBuilder cb = sf.getCriteriaBuilder();

			CriteriaQuery<DataIndex> query = cb.createQuery(DataIndex.class);

			Root<Datasource> from = query.from(Datasource.class);

			query.select(from.get(Datasource_.dataIndex));

			query.where(from.get(Datasource_.id).in(request.getDatasourceId()));

			return session
				.createQuery(query)
				.getSingleResult()
				.onItem()
				.transformToUni(dataIndex -> indexerEvents.generateDocTypeFields(dataIndex));

		});

	}

	@Path("/get-mappings-from-doc-types")
	@POST
	public Uni<Map<String, Object>> getMappings(
		GetMappingsFromDocTypesRequest request) {

		return getMappingsFromDocTypes(request.getDocTypeIds());

	}

	@Path("/create-data-index-from-doc-types")
	@POST
	public Uni<DataIndex> createDataIndexFromDocTypes(
		CreateDataIndexFromDocTypesRequest request) {

		String indexName;

		if (request.getIndexName() == null) {
			indexName = "data-" + OffsetDateTime.now();
		}
		else {
			indexName = request.getIndexName();
		}

		return sf.withTransaction(s -> {

			List<Long> docTypeIds = request.getDocTypeIds();

			Uni<List<DocType>> docTypeListUni =
				_findDocTypes(docTypeIds, s);

			return docTypeListUni
				.onItem()
				.transformToUni(docTypeList -> {

					if (docTypeList.size() != docTypeIds.size()) {
						throw new RuntimeException(
							"docTypeIds found: " + docTypeList.size() +
							" docTypeIds requested: " + docTypeIds.size());
					}

					DataIndex dataIndex = new DataIndex();

					dataIndex.setDescription("auto-generated");

					dataIndex.setName(indexName);

					dataIndex.setDocTypes(docTypeList);

					return s.persist(dataIndex)
						.map(__ -> dataIndex)
						.call(s::flush)
						.call((di) -> Uni.createFrom().emitter((sink) -> {

							try {
								IndicesClient indices = client.indices();

								Map<String, Object> mappings =
									di
										.getDocTypes()
										.stream()
										.map(DocType::getDocTypeFields)
										.flatMap(Collection::stream)
										.collect(
											Collectors.collectingAndThen(
												Collectors.toList(),
												DataIndexResource::docTypeFieldsToMappings)
										);

								PutComposableIndexTemplateRequest putComposableIndexTemplateRequest =
									new PutComposableIndexTemplateRequest();

								ComposableIndexTemplate composableIndexTemplate =
									new ComposableIndexTemplate(
										List.of(indexName),
										new Template(null, new CompressedXContent(Json.encode(mappings)), null),
										null, null, null, null);

								putComposableIndexTemplateRequest
									.name(indexName + "-template")
									.indexTemplate(composableIndexTemplate);

								indices.putIndexTemplate(putComposableIndexTemplateRequest, RequestOptions.DEFAULT);

								sink.complete(null);
							}
							catch (Exception e) {
								sink.fail(e);
							}

						}));

				});

		});

	}

	private Uni<Map<String, Object>> getMappingsFromDocTypes(
		List<Long> docTypeIds) {

		return sf.withTransaction(session -> {

			Uni<List<DocType>> docTypeListUni = _findDocTypes(docTypeIds, session);

			return docTypeListUni
				.map(docTypeList ->
					docTypeList
						.stream()
						.map(DocType::getDocTypeFields)
						.flatMap(Collection::stream)
						.collect(
							Collectors.collectingAndThen(
								Collectors.toList(),
								DataIndexResource::docTypeFieldsToMappings)
						)
				);

		});
	}

	private Uni<List<DocType>> _findDocTypes(
		List<Long> docTypeIds, Mutiny.Session session) {

		CriteriaBuilder cb = sf.getCriteriaBuilder();

		CriteriaQuery<DocType> query = cb.createQuery(DocType.class);

		Root<DocType> from = query.from(DocType.class);

		from.fetch(DocType_.docTypeFields);

		query.where(from.get(DocType_.id).in(docTypeIds));

		query.distinct(true);

		return session
			.createQuery(query)
			.getResultList();
	}

	public static Map<String, Object> docTypeFieldsToMappings(
		List<DocTypeField> fieldNames) {

		Map<String, Object> properties = new LinkedHashMap<>();

		List<DocTypeField> orderedFieldNames = fieldNames
			.stream()
			.sorted(Comparator.comparingInt((DocTypeField f) -> f.getName().length()))
			.collect(Collectors.toList());

		for (DocTypeField docTypeField : orderedFieldNames) {

			String[] fieldNamesArray = docTypeField.getName().split("\\.");

			Map<String, Object> current = properties;

			for (int i = 0; i < fieldNamesArray.length; i++) {

				String fieldName = fieldNamesArray[i];

				boolean isLast = i == fieldNamesArray.length - 1;
				boolean isFields = isLast && current.containsKey("type");

				current = (Map<String, Object>)current.computeIfAbsent(
					isFields ? "fields" : "properties", k -> new LinkedHashMap<>());

				current =
					(Map<String, Object>)current.computeIfAbsent(
						fieldName, k -> new LinkedHashMap<>());

				if (isLast) {

					FieldType fieldType =
						docTypeField.getFieldType();

					current.put("type", fieldType.getType());

					Analyzer analyzer = docTypeField.getAnalyzer();

					if (analyzer != null) {
						current.put("analyzer", analyzer.name());
					}

					if (isFields) {
						if (fieldType == FieldType.KEYWORD) {
							current.put("ignore_above", 256);
						}
					}
				}

			}

		}

		return properties;

	}

	@Data
	@AllArgsConstructor
	@NoArgsConstructor
	public static class AutoGenerateDocTypesRequest {
		private long datasourceId;
	}

	@Data
	@AllArgsConstructor
	@NoArgsConstructor
	public static class GetMappingsFromDocTypesRequest {
		private List<Long> docTypeIds;
	}

	@Data
	@AllArgsConstructor
	@NoArgsConstructor
	public static class CreateDataIndexFromDocTypesRequest {
		private List<Long> docTypeIds;
		private String indexName;
	}

	@Inject
	Mutiny.SessionFactory sf;

	@Inject
	IndexerEvents indexerEvents;

	@Inject
	RestHighLevelClient client;

}
